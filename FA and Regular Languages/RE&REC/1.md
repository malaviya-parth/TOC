## RE -> Recursive Enumemrable
## REC -> Recursive

- RE and REC are Langugaes generated by type-0 grammar
- REC is subset of RE   
- If there is a type 0 grammar then language is RE ✅
- If there is a type 0 grammar then language is REC ❌ (May or may not be)
- If there is a type 1 grammar then language is REC ✅ (As type-1 gives CSL and CSL is subset of REC.)
<br/><br/>
- REC is not given any specific grammar name

- If Language is REC then problem is decidable
- If Language is RE then problem is semi-decidable
- If Language of a problem is not RE then problem is undecidable
<br/><br/>

- A Language L is said to be RE if and only if there exist a procedure which can tell whether a string w belongs to L or not.
- A Language L is said to be REC if and only if there exist an algorithm which can tell whether a string w belongs to L or not.
- Algorithms can give either yes/no answer
- Procedures can give yes/no/undefined answer sometimes it may not terminate
<br/><br/>

- For RE acceptance device is Turing Machine
- For REC acceptance device is Halting Turing Machine

**Example**
- L = { $a^{p}$ | p is prime}
- To check whether a given string belongs to L we can check through like from 2 to $\sqrt{p}$ whether it is divisible or not. If it is divisible then it is not prime. If it is not divisible then it is prime. So, we can say that L is REC, as it gives either yes/no answer and it terminates.

**RE Example**
- Set of all C programs which are syntactically correct
- Set of all C programs which do not have infinite loop

**Non-RE Example**
- Set of all C programs which do not have infinite loop